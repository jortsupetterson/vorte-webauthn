// src/endpoints/challenge.ts
import { Bool, Num, Str, OpenAPIRoute } from "chanfana";
import { z } from "zod";
import type { AppContext } from "../types";

const toBase64Url = (bytes: Uint8Array): string => {
  let ascii = "";
  for (let index = 0; index < bytes.length; index++)
    ascii += String.fromCharCode(bytes[index]);
  return btoa(ascii)
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=+$/u, "");
};

const deriveRpId = (hostname: string): string => {
  const clean = hostname.replace(/:\d+$/u, "");
  if (clean === "localhost" || clean === "127.0.0.1") return clean;
  return "vorte.app";
};

const ratelimitCache: Map<string, number> = new Map();
const WINDOW_MS = 60_000;
const LIMIT_HEADER = "1;w=60";
const FINGERPRINT_RE = /^[a-f0-9]{32}$/i;

export class Challenge extends OpenAPIRoute {
  schema = {
    tags: ["WebAuthn"],
    summary:
      'Returns a "transactionId" and "options" to start a fully discoverable WebAuthn assertion.',
    request: {
      headers: z.object({
        "x-fingerprint": Str()
          .regex(
            FINGERPRINT_RE,
            "Invalid X-Fingerprint format (expected 32 hex characters)"
          )
          .openapi({
            example: "0e75dfbfc3a182fa1f652635f7ee588c",
            description: "Browser fingerprint generated by fingerprint.js",
          }),
      }),
    },
    responses: {
      "200": {
        description: "WebAuthn assertion init payload",
        content: {
          "application/json": {
            schema: z.object({
              success: Bool(),
              result: z.object({
                transactionId: Str(),
                options: z.object({
                  challenge: Str(),
                  rpId: Str(),
                  userVerification: Str(),
                  timeout: Num(),
                }),
              }),
            }),
            examples: {
              ok: {
                value: {
                  success: true,
                  result: {
                    transactionId: "0ff72376-a0b7-4a92-a2e9-a117ef916302",
                    options: {
                      challenge: "IEm_pXJwb3-GVyBcQNhj1-gDSiLT_v-fRQE_A3j-N3o",
                      rpId: "vorte.app",
                      userVerification: "required",
                      timeout: 60000,
                    },
                  },
                },
              },
            },
          },
        },
      },
      "400": {
        description: "Missing or invalid X-Fingerprint header",
        content: {
          "application/json": {
            schema: z.object({ success: Bool(), error: Str() }),
          },
        },
      },
      "429": {
        description: "Too many requests (edge ratelimit per fingerprint)",
        content: {
          "application/json": {
            schema: z.object({ success: Bool(), error: Str() }),
          },
        },
      },
    },
  };

  async handle(ctx: AppContext) {
    ctx.header("Cache-Control", "private, max-age=60, s-maxage=0");
    ctx.header("Vary", "X-Fingerprint");
    ctx.header("Content-Type", "application/json; charset=utf-8");

    const data = await this.getValidatedData<typeof this.schema>();
    const fingerprint = data.headers["x-fingerprint"].trim();

    const hostname = new URL(ctx.req.url).hostname;
    const rpId = deriveRpId(hostname);
    const key = `${rpId}::${fingerprint}`;

    const now = Date.now();
    const until = ratelimitCache.get(key);
    if (typeof until === "number" && until > now) {
      const left = Math.max(1, Math.ceil((until - now) / 1000));
      ctx.header("RateLimit-Limit", LIMIT_HEADER);
      ctx.header("RateLimit-Remaining", "0");
      ctx.header("RateLimit-Reset", String(left));
      ctx.header("Retry-After", String(left));
      ctx.status(429);
      return {
        success: false,
        error: "Only 1 challenge per 60 seconds (per fingerprint)",
      };
    }

    ratelimitCache.set(key, now + WINDOW_MS);

    ctx.header("RateLimit-Limit", LIMIT_HEADER);
    ctx.header("RateLimit-Remaining", "0");
    ctx.header("RateLimit-Reset", "60");

    const transactionId = crypto.randomUUID();
    const rnd = new Uint8Array(32);
    crypto.getRandomValues(rnd);
    const challenge = toBase64Url(rnd);

    return {
      success: true,
      result: {
        transactionId,
        options: {
          challenge,
          rpId,
          userVerification: "required",
          timeout: 60_000,
        },
      },
    };
  }
}
